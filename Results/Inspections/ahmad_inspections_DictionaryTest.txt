Problem: DictionaryTest

---------------------
PUT_AddContract

Disjunctive (PexChoose): False
Disjunctive (Alternate Semantics): False
Disjunctive (Truly): False

notes:

In agreement
=====
k == 0

learned postcondition: (New_dContainsKeyX && New_dContainsValueY && New_dCount == Old_dCount + 1 && New_x == Old_x && New_y == Old_y && (!(Old_dContainsKeyX)) && New_dCount != Old_dCount)

simplified postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_dCount == 1 + Old_dCount && New_x == Old_x && New_y == Old_y && (!(Old_dContainsKeyX))))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 1

learned postcondition: (New_dContainsKeyX && New_dContainsValueY && New_dCount == Old_dCount + 1 && New_x == Old_x && New_y == Old_y && (!(Old_dContainsKeyX)) && New_dCount != Old_dCount)

simplified postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_dCount == 1 + Old_dCount && New_x == Old_x && New_y == Old_y && (!(Old_dContainsKeyX))))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: (New_dContainsKeyX && New_dContainsValueY && New_dCount == Old_dCount + 1 && New_x == Old_x && New_y == Old_y && (!(Old_dContainsKeyX)) && New_dCount != Old_dCount)

simplified postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_dCount == 1 + Old_dCount && New_x == Old_x && New_y == Old_y && (!(Old_dContainsKeyX))))

predicates: None

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_RemoveContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

notes:

In agreement

=====
k == 0

learned postcondition: (New_x == Old_x && (!(New_dContainsKeyX)))

simplified postcondition: ((New_x == Old_x && (!(New_dContainsKeyX))))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_x == Old_x && (!(New_dContainsKeyX))) && (((New_Ret && New_dCount == Old_dCount - 1 && New_dCount != Old_dCount) && Old_dContainsKeyX) || ((New_dCount == Old_dCount && (!(New_Ret))) && (!(Old_dContainsKeyX)))))

simplified postcondition: ((New_x == Old_x && (!(New_dContainsKeyX)) && New_Ret && New_dCount == -1 + Old_dCount && Old_dContainsKeyX) || (New_x == Old_x && (!(New_dContainsKeyX)) && New_dCount == Old_dCount && (!(New_Ret)) && (!(Old_dContainsKeyX))))

predicates: Old_dContainsKeyX

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: ((New_x == Old_x && (!(New_dContainsKeyX))) && ((((New_Ret && New_dCount == Old_dCount - 1 && New_dCount != Old_dCount) && (((New_dCount == Old_x &&  Old_x != Old_dCount &&  New_x != Old_dCount &&  Old_x == New_dCount) && New_x == New_dCount) || ((Old_x != New_dCount &&  New_x != New_dCount) && (!(New_x == New_dCount))))) && Old_dContainsKeyX) || (((New_dCount == Old_dCount && (!(New_Ret))) && (((New_x == Old_dCount &&  Old_x == Old_dCount &&  Old_x == New_dCount) && New_x == New_dCount) || ((Old_x != Old_dCount &&  New_x != Old_dCount &&  Old_x != New_dCount &&  New_x != New_dCount) && (!(New_x == New_dCount))))) && (!(Old_dContainsKeyX)))))

simplified postcondition: ((New_x == Old_x && (!(New_dContainsKeyX)) && New_Ret && New_dCount == -1 + Old_dCount && Old_dContainsKeyX) || (New_x == Old_x && (!(New_dContainsKeyX)) && New_dCount == Old_dCount && (!(New_Ret)) && (!(Old_dContainsKeyX))))

predicates: Old_dContainsKeyX

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_GetContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

notes:

Given runs with update features, Get is now a disjunctive case and k=1,k=2 produce the best such disjunctive formula/concept.

=====
k == 0

learned postcondition: (Old_dContainsKeyX && New_dContainsKeyX && New_dCount == Old_dCount && New_x == Old_x)

simplified postcondition: ((Old_dContainsKeyX && New_dContainsKeyX && New_dCount == Old_dCount && New_x == Old_x))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: (Old_dContainsKeyX && New_dContainsKeyX && New_dCount == Old_dCount && New_x == Old_x)

simplified postcondition: ((Old_dContainsKeyX && New_dContainsKeyX && New_dCount == Old_dCount && New_x == Old_x))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: (Old_dContainsKeyX && New_dContainsKeyX && New_dCount == Old_dCount && New_x == Old_x)

simplified postcondition: ((Old_dContainsKeyX && New_dContainsKeyX && New_dCount == Old_dCount && New_x == Old_x))

predicates: None

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_SetContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

notes:

In agreement
=====
k == 0

learned postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y))

simplified postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y) && (((New_dCount == Old_dCount) && Old_dContainsKeyX) || ((New_dCount == Old_dCount + 1 && New_dCount != Old_dCount) && (!(Old_dContainsKeyX)))))

simplified postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y && New_dCount == Old_dCount && Old_dContainsKeyX) || (New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y && New_dCount == 1 + Old_dCount && (!(Old_dContainsKeyX))))

predicates: Old_dContainsKeyX

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y) && ((((New_dCount == Old_dCount) && (((New_y == Old_x &&  Old_y == Old_x &&  Old_y == New_x) && New_y == New_x) || ((Old_y != Old_x &&  New_y != Old_x &&  Old_y != New_x &&  New_y != New_x) && (!(New_y == New_x))))) && Old_dContainsKeyX) || (((New_dCount == Old_dCount + 1 && New_dCount != Old_dCount) && (((Old_y == Old_dCount &&  Old_y != New_dCount &&  New_y != New_dCount) && New_y == Old_dCount) || ((Old_y != Old_dCount &&  New_y != Old_dCount) && (!(New_y == Old_dCount))))) && (!(Old_dContainsKeyX)))))

simplified postcondition: ((New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y && New_dCount == Old_dCount && Old_dContainsKeyX) || (New_dContainsKeyX && New_dContainsValueY && New_x == Old_x && New_y == Old_y && New_dCount == 1 + Old_dCount && (!(Old_dContainsKeyX))))

predicates: Old_dContainsKeyX

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_ContainsKeyContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

concern:
see hashSet Contains

notes:

In agreement; see HashSet contains.

=====
k == 0

learned postcondition: (New_dCount == Old_dCount && New_x == Old_x)

simplified postcondition: ((New_dCount == Old_dCount && New_x == Old_x))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_dCount == Old_dCount && New_x == Old_x) && (((New_Ret && Old_dContainsKeyX) && New_dContainsKeyX) || (((!(New_Ret)) && (!(Old_dContainsKeyX))) && (!(New_dContainsKeyX)))))

simplified postcondition: ((New_dCount == Old_dCount && New_x == Old_x && New_Ret && Old_dContainsKeyX && New_dContainsKeyX) || (New_dCount == Old_dCount && New_x == Old_x && (!(New_Ret)) && (!(Old_dContainsKeyX)) && (!(New_dContainsKeyX))))

predicates: New_dContainsKeyX
Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: ((New_dCount == Old_dCount && New_x == Old_x) && ((((New_Ret && Old_dContainsKeyX) && (((New_x == Old_dCount &&  Old_x == Old_dCount &&  Old_x == New_dCount) && New_x == New_dCount) || ((Old_x != Old_dCount &&  New_x != Old_dCount &&  Old_x != New_dCount &&  New_x != New_dCount) && (!(New_x == New_dCount))))) && New_dContainsKeyX) || ((((!(New_Ret)) && (!(Old_dContainsKeyX))) && (((New_x == Old_dCount &&  Old_x == Old_dCount &&  Old_x == New_dCount) && New_x == New_dCount) || ((Old_x != Old_dCount &&  New_x != Old_dCount &&  Old_x != New_dCount &&  New_x != New_dCount) && (!(New_x == New_dCount))))) && (!(New_dContainsKeyX)))))

simplified postcondition: ((New_dCount == Old_dCount && New_x == Old_x && New_Ret && Old_dContainsKeyX && New_dContainsKeyX) || ((!(New_Ret)) && (!(Old_dContainsKeyX)) && (!(New_dContainsKeyX)) && Old_x == Old_dCount && Old_x == New_dCount && New_x == New_dCount) || (New_dCount == Old_dCount && New_x == Old_x && (!(New_Ret)) && (!(Old_dContainsKeyX)) && (!(New_dContainsKeyX)) && (!(New_x == New_dCount))))

predicates: New_dContainsKeyX

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_ContainsValueContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

concern:
see hashSet Contains

notes:

In agreement; see HashSet contains.

=====
k == 0

learned postcondition: (New_dCount == Old_dCount && New_y == Old_y)

simplified postcondition: ((New_dCount == Old_dCount && New_y == Old_y))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_dCount == Old_dCount && New_y == Old_y) && (((New_Ret && Old_dContainsValueY) && New_dContainsValueY) || (((!(New_Ret)) && (!(Old_dContainsValueY))) && (!(New_dContainsValueY)))))

simplified postcondition: ((New_dCount == Old_dCount && New_y == Old_y && New_Ret && Old_dContainsValueY && New_dContainsValueY) || (New_dCount == Old_dCount && New_y == Old_y && (!(New_Ret)) && (!(Old_dContainsValueY)) && (!(New_dContainsValueY))))

predicates: New_dContainsValueY

Any: pass

L: pass

SubL: pass

=====
k == 2

learned postcondition: ((New_dCount == Old_dCount && New_y == Old_y) && ((((New_Ret && Old_dContainsValueY) && (((New_y == Old_dCount &&  Old_y == Old_dCount &&  Old_y == New_dCount) && New_y == New_dCount) || ((Old_y != Old_dCount &&  New_y != Old_dCount &&  Old_y != New_dCount &&  New_y != New_dCount) && (!(New_y == New_dCount))))) && New_dContainsValueY) || ((((!(New_Ret)) && (!(Old_dContainsValueY))) && (((New_y == Old_dCount &&  Old_y == Old_dCount &&  Old_y == New_dCount) && New_y == New_dCount) || ((Old_y != Old_dCount &&  New_y != Old_dCount &&  Old_y != New_dCount &&  New_y != New_dCount) && (!(New_y == New_dCount))))) && (!(New_dContainsValueY)))))

simplified postcondition: ((New_dCount == Old_dCount && New_y == Old_y && New_Ret && Old_dContainsValueY && New_dContainsValueY) || ((!(New_Ret)) && (!(Old_dContainsValueY)) && (!(New_dContainsValueY)) && Old_y == Old_dCount && Old_y == New_dCount && New_y == New_dCount) || (New_dCount == Old_dCount && New_y == Old_y && (!(New_Ret)) && (!(Old_dContainsValueY)) && (!(New_dContainsValueY)) && (!(New_y == New_dCount))))

predicates: New_dContainsValueY

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_CountContract

Disjunctive (PexChoose): False
Disjunctive (Alternate Semantics): False
Disjunctive (Truly): False

Notes: 

This is a similar to Stack Count where the ideal post is cojunctive but disjunctive formulas overfit the test generator.
Unlike Stack count, this problem is strickly a test generator problem and not expressiveness. The formula should have not split.
Technically this is a missed conjuctive case
=====
k == 0

learned postcondition: (New_dCount == Old_dCount && New_Ret == Old_dCount && New_Ret == New_dCount)

simplified postcondition: ((New_Ret == Old_dCount && New_Ret == New_dCount))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 1

learned postcondition: (New_dCount == Old_dCount && New_Ret == Old_dCount && New_Ret == New_dCount)

simplified postcondition: ((New_Ret == Old_dCount && New_Ret == New_dCount))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 2

learned postcondition: (New_dCount == Old_dCount && New_Ret == Old_dCount && New_Ret == New_dCount)

simplified postcondition: ((New_Ret == Old_dCount && New_Ret == New_dCount))

predicates: None

Any: reject

L: reject

SubL: Pass

---------------------