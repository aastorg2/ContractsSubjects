Problem: StackTest

---------------------
PUT_PushContract

Disjunctive (PexChoose): False
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

Notes: 
The is exist a disjunction that be expressed with alternate Semantics: allTrue && (Old_s1ContainsX ||!(New_x == Old_Top))

=====
k == 0

learned postcondition: (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

simplified postcondition: ((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

simplified postcondition: ((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))

predicates: None

Any: reject

L: reject

SubL: reject

=====
k == 2

learned postcondition: (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

simplified postcondition: ((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))
 
predicates: None

Any: reject

L: reject

SubL: reject

---------------------
PUT_PopContract

Disjunctive (PexChoose): False
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

Notes: 
The is exist a disjunction that can be expressed with alternate Semantics: allTrue && (New_ContainsNewRet ||!(New_Ret == New_Top)))

=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

simplified postcondition: ((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

simplified postcondition: ((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))

predicates: None

Any: reject

L: reject

SubL: reject

=====
k == 2

learned postcondition: (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

simplified postcondition: ((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))

predicates: None

Any: reject

L: reject

SubL: reject

---------------------
PUT_PeekContract

Disjunctive (PexChoose): False
Disjunctive (Alternate Semantics): False
Disjunctive (Truly): False

Note: This case is labeled fined, so this note is not about correctness. 
However running this case with the updated feature: bool New_ContainsNewRet = s1.Contains(New_Ret);
produces what I believe to be a syntaxtically different but semantically equivalent postcondition:

alternate: ((New_ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
PexChoose: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

reason: New_Ret == New_Top implies New_ContainsNewRet

=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

simplified postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

predicates: None


Any: Pass

L: Pass

SubL: Pass

=====
k == 1

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

simplified postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

simplified postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

predicates: None

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_CountContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): False
Disjunctive (Truly): False

Notes: 
The Any, L and Subl entries new to be re-evaluated because proper postcondition to be learned using strickly PexChoose Semantics
is ((New_Ret == Old_s1Count && New_Ret == New_s1Count)) with excludes New_Top == Old_Top in the current post.
((New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)) --> tighter postcondition.

** discuss with professors **

For k == 1, the post condition overfits this case. The formula is best in sub logic but because we cannot expres Count > 1,
then algorithm chooses the stronger predicate, containsNewRet, which implies there is at least one element. However, it is too
strick as it also requires that such element is the return value for count.

for k ==2, although, a good attempt. It suffers from overfitting and inexpressiveness of logic. 
Thus, it further splits in uninmformitive/unintersting predicates for k=2 depth. k=1 depth is same as above. 
Nevertheless, it is a refinement on k =1 because it does add new information by further split formula from depth k =1.


=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

simplified postcondition: ((New_Ret == Old_s1Count && New_Ret == New_s1Count))

predicates: None

Any: reject

L: reject

SubL: reject

SubL: reject

pex time: 74.46192598342896

learn time: 4.122227907180786

Samples: 9

=====
k == 1

learned postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_Top) && New_ContainsNewRet) || (true && (!(New_ContainsNewRet)))))

simplified postcondition: ((New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Top == Old_Top) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && (!(New_ContainsNewRet))))

predicates: New_ContainsNewRet

Any: reject

L: reject

SubL: Pass

pex time: 106.25021266937256

learn time: 22.74586844444275

Samples: 17

k0 -> k1: False

k1 -> k0: False

=====
k == 2

learned postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == Old_Top) && New_Ret == New_Top) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == 0 &&  New_Ret == 0 &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Ret != Old_Top) && (!(New_Ret == Old_Top))))) && (!(New_ContainsNewRet)))))

simplified postcondition: ((New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_ContainsNewRet) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Ret == 0 && (!(New_ContainsNewRet))) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && (!(New_Ret == Old_Top)) && (!(New_ContainsNewRet))))

predicates: New_ContainsNewRet

Any: reject

L: Pass

SubL: Pass

pex time: 151.08302569389343

learn time: 61.227513551712036

Samples: 27

k0 -> k2: False

k1 -> k2: False

---------------------
PUT_ContainsContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

Notes:

for k == 0: Any, L, and Subl, should be reject because a tighter post can be learned ((New_s1Count == Old_s1Count) && Old_Top == New_Top)
Reason for flaw: PexChoose Semantics.

for k == 1: this is fine and correct. Notice though that the predicate New_Top == Old_Top is moved from the always true 
to the conditional part of the formula. This is also due to PexChoose semantics.

for k==2: this is same as k == 1 
=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count)

simplified postcondition: ((New_s1Count == Old_s1Count))

predicates: None

Any: reject

L: reject

SubL: reject

pex time: 51.30953407287598

learn time: 2.5732429027557373

Samples: 10

=====
k == 1

learned postcondition: ((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

simplified postcondition: ((New_s1Count == Old_s1Count && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX))) || (New_s1Count == Old_s1Count && New_Ret && Old_s1ContainsX && New_Top == Old_Top && New_s1ContainsX))

predicates: New_s1ContainsX

Any: Pass

L: Pass

SubL: Pass

pex time: 65.84815168380737

learn time: 15.691133737564087

Samples: 15

k0 -> k1: False

k1 -> k0: False

=====
k == 2

learned postcondition: ((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

simplified postcondition: ((New_s1Count == Old_s1Count && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX))) || (New_s1Count == Old_s1Count && New_Ret && Old_s1ContainsX && New_Top == Old_Top && New_s1ContainsX))

predicates: New_s1ContainsX

Any: Pass

L: Pass

SubL: Pass

pex time: 90.13938546180725

learn time: 59.37993359565735

Samples: 34

k0 -> k2: False

k1 -> k2: True