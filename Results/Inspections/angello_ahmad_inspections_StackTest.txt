Problem: StackTest

---------------------
PUT_PushContract

Disjunctive (PexObserve): False
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

Notes: The is exist a disjunction that be expressed with alternate Semantics: allTrue && (Old_s1ContainsX ||!(New_x == Old_Top))

=====
k == 0

learned postcondition: (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

simplified postcondition: ((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

simplified postcondition: ((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))

predicates: None

Any: reject

L: reject

SubL: reject

=====
k == 2

learned postcondition: (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

simplified postcondition: ((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))
 
predicates: None

Any: reject

L: reject

SubL: reject

---------------------
PUT_PopContract

Disjunctive (PexObserve): False
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

Notes: The is exist a disjunction that can be expressed with alternate Semantics: allTrue && (New_ContainsNewRet ||!(New_Ret == New_Top)))

=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

simplified postcondition: ((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

simplified postcondition: ((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))

predicates: None

Any: reject

L: reject

SubL: reject

=====
k == 2

learned postcondition: (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

simplified postcondition: ((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))

predicates: None

Any: reject

L: reject

SubL: reject

---------------------
PUT_PeekContract

Disjunctive (PexObserve): False
Disjunctive (Alternate Semantics): False
Disjunctive (Truly): False

Note: This case is labeled fined, so this note is not about correctness. 
However running this case with the updated feature: bool New_ContainsNewRet = s1.Contains(New_Ret);
produces what I believe to be a syntaxtically different but semantically equivalent postcondition:

alternate: ((New_ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
PexChoose: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

reason: New_Ret == New_Top implies New_ContainsNewRet

=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

simplified postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

predicates: None


Any: Pass

L: Pass

SubL: Pass

=====
k == 1

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

simplified postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

simplified postcondition: ((New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))

predicates: None

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_CountContract

Disjunctive (PexObserve): False
Disjunctive (Alternate Semantics): False
Disjunctive (Truly): False

Note: The Any, L and Subl entries new to be re-evaluated because proper postcondition to be learned using strickly PexObserve Semantics
is ((New_Ret == Old_s1Count && New_Ret == New_s1Count)) with excludes New_Top == Old_Top in the current post.
((New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count))
Ahamd you can confirm this.

I am not sure but all the An, L and Subl entries would go to false

=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

simplified postcondition: ((New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 1

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

simplified postcondition: ((New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

simplified postcondition: ((New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count))

predicates: None


Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_ContainsContract

Disjunctive (PexObserve): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

=====
k == 0

learned postcondition: (New_s1Count == Old_s1Count && New_Top == Old_Top)

simplified postcondition: ((New_s1Count == Old_s1Count && New_Top == Old_Top))

predicates: None


Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_s1Count == Old_s1Count && New_Top == Old_Top) && (((New_Ret && Old_s1ContainsX) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

simplified postcondition: ((New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret && Old_s1ContainsX && New_s1ContainsX) || (New_s1Count == Old_s1Count && New_Top == Old_Top && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX))))

predicates: New_s1ContainsX


Any: reject

L: reject

SubL: Pass

=====
k == 2

learned postcondition: ((New_s1Count == Old_s1Count && New_Top == Old_Top) && ((((New_Ret && Old_s1ContainsX) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

simplified postcondition: ((New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret && Old_s1ContainsX && New_s1ContainsX) || ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count) || (New_s1Count == Old_s1Count && New_Top == Old_Top && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && (!(New_Top == New_s1Count))))

predicates: New_s1ContainsX

Any: Pass

L: Pass

SubL: Pass

---------------------