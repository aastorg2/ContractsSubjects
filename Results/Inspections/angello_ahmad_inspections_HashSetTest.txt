Problem: HashSetTest

---------------------
PUT_AddContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

notes:
In agreement

=====
k == 0

learned postcondition: (New_hsContainsX && New_x == Old_x)

simplified postcondition: ((New_hsContainsX && New_x == Old_x))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_hsContainsX && New_x == Old_x) && (((New_hsCount == Old_hsCount && (!(New_Ret))) && Old_hsContainsX) || ((New_Ret && New_hsCount == Old_hsCount + 1 && New_hsCount != Old_hsCount) && (!(Old_hsContainsX)))))

simplified postcondition: ((New_hsContainsX && New_x == Old_x && New_hsCount == Old_hsCount && (!(New_Ret)) && Old_hsContainsX) || (New_hsContainsX && New_x == Old_x && New_Ret && New_hsCount == 1 + Old_hsCount && (!(Old_hsContainsX))))

predicates: Old_hsContainsX

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: ((New_hsContainsX && New_x == Old_x) && ((((New_hsCount == Old_hsCount && (!(New_Ret))) && (((New_x == Old_hsCount &&  Old_x == Old_hsCount &&  Old_x == New_hsCount) && New_x == New_hsCount) || ((Old_x != Old_hsCount &&  New_x != Old_hsCount &&  Old_x != New_hsCount &&  New_x != New_hsCount) && (!(New_x == New_hsCount))))) && Old_hsContainsX) || (((New_Ret && New_hsCount == Old_hsCount + 1 && New_hsCount != Old_hsCount) && (((Old_x == Old_hsCount &&  Old_x != New_hsCount &&  New_x != New_hsCount) && New_x == Old_hsCount) || ((Old_x != Old_hsCount &&  New_x != Old_hsCount) && (!(New_x == Old_hsCount))))) && (!(Old_hsContainsX)))))

simplified postcondition: ((New_hsContainsX && New_x == Old_x && New_hsCount == Old_hsCount && (!(New_Ret)) && Old_hsContainsX) || (New_hsContainsX && New_x == Old_x && New_Ret && New_hsCount == 1 + Old_hsCount && (!(Old_hsContainsX))))

predicates: Old_hsContainsX

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_RemoveContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

notes:
In agreement

=====
k == 0

learned postcondition: (New_x == Old_x && (!(New_hsContainsX)))

simplified postcondition: ((New_x == Old_x && (!(New_hsContainsX))))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_x == Old_x && (!(New_hsContainsX))) && (((New_Ret && New_hsCount == Old_hsCount - 1 && New_hsCount != Old_hsCount) && Old_hsContainsX) || ((New_hsCount == Old_hsCount && (!(New_Ret))) && (!(Old_hsContainsX)))))

simplified postcondition: ((New_x == Old_x && (!(New_hsContainsX)) && New_Ret && New_hsCount == -1 + Old_hsCount && Old_hsContainsX) || (New_x == Old_x && (!(New_hsContainsX)) && New_hsCount == Old_hsCount && (!(New_Ret)) && (!(Old_hsContainsX))))

predicates: Old_hsContainsX

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: ((New_x == Old_x && (!(New_hsContainsX))) && ((((New_Ret && New_hsCount == Old_hsCount - 1 && New_hsCount != Old_hsCount) && (((New_hsCount == Old_x &&  Old_x != Old_hsCount &&  New_x != Old_hsCount &&  Old_x == New_hsCount) && New_x == New_hsCount) || ((Old_x != New_hsCount &&  New_x != New_hsCount) && (!(New_x == New_hsCount))))) && Old_hsContainsX) || (((New_hsCount == Old_hsCount && (!(New_Ret))) && (((New_x == Old_hsCount &&  Old_x == Old_hsCount &&  Old_x == New_hsCount) && New_x == New_hsCount) || ((Old_x != Old_hsCount &&  New_x != Old_hsCount &&  Old_x != New_hsCount &&  New_x != New_hsCount) && (!(New_x == New_hsCount))))) && (!(Old_hsContainsX)))))

simplified postcondition: ((New_x == Old_x && (!(New_hsContainsX)) && New_Ret && New_hsCount == -1 + Old_hsCount && Old_hsContainsX) || (New_x == Old_x && (!(New_hsContainsX)) && New_hsCount == Old_hsCount && (!(New_Ret)) && (!(Old_hsContainsX))))

predicates: Old_hsContainsX

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_CountContract

Disjunctive (PexChoose): False
Disjunctive (Alternate Semantics): False
Disjunctive (Truly): False

notes:

In agreement
=====
k == 0

learned postcondition: (New_hsCount == Old_hsCount && New_Ret == Old_hsCount && New_Ret == New_hsCount)

simplified postcondition: ((New_Ret == Old_hsCount && New_Ret == New_hsCount))

predicates: None

Any: Pass

L: Pass

SubL: Pass

=====
k == 1

learned postcondition: (New_hsCount == Old_hsCount && New_Ret == Old_hsCount && New_Ret == New_hsCount)

simplified postcondition: ((New_Ret == Old_hsCount && New_Ret == New_hsCount))

predicates: None

Any: True

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: (New_hsCount == Old_hsCount && New_Ret == Old_hsCount && New_Ret == New_hsCount)

simplified postcondition: ((New_Ret == Old_hsCount && New_Ret == New_hsCount))

predicates: None

Any: Pass

L: Pass

SubL: Pass

---------------------
PUT_ContainsContract

Disjunctive (PexChoose): True
Disjunctive (Alternate Semantics): True
Disjunctive (Truly): True

concern: 
k2 is not a refinement; the reason it appear to be a refinement is because the current implementation of the algorithm does not consider ancestors
alwaysTrue parts of the formula when doing the implication check.  

notes:
k2 is not a refinement on k1 so k1 is perfect. Implication k1 => k2 is valid.

=====
k == 0

learned postcondition: (New_hsCount == Old_hsCount && New_x == Old_x)

simplified postcondition: ((New_hsCount == Old_hsCount && New_x == Old_x))

predicates: None

Any: reject

L: reject

SubL: Pass

=====
k == 1

learned postcondition: ((New_hsCount == Old_hsCount && New_x == Old_x) && (((New_Ret && Old_hsContainsX) && New_hsContainsX) || (((!(New_Ret)) && (!(Old_hsContainsX))) && (!(New_hsContainsX)))))

simplified postcondition: ((New_hsCount == Old_hsCount && New_x == Old_x && New_Ret && Old_hsContainsX && New_hsContainsX) || (New_hsCount == Old_hsCount && New_x == Old_x && (!(New_Ret)) && (!(Old_hsContainsX)) && (!(New_hsContainsX))))

predicates: New_hsContainsX

Any: Pass

L: Pass

SubL: Pass

=====
k == 2

learned postcondition: ((New_hsCount == Old_hsCount && New_x == Old_x) && ((((New_Ret && Old_hsContainsX) && (((New_x == Old_hsCount &&  Old_x == Old_hsCount &&  Old_x == New_hsCount) && New_x == New_hsCount) || ((Old_x != Old_hsCount &&  New_x != Old_hsCount &&  Old_x != New_hsCount &&  New_x != New_hsCount) && (!(New_x == New_hsCount))))) && New_hsContainsX) || ((((!(New_Ret)) && (!(Old_hsContainsX))) && (((New_x == Old_hsCount &&  Old_x == Old_hsCount &&  Old_x == New_hsCount) && New_x == New_hsCount) || ((Old_x != Old_hsCount &&  New_x != Old_hsCount &&  Old_x != New_hsCount &&  New_x != New_hsCount) && (!(New_x == New_hsCount))))) && (!(New_hsContainsX)))))

simplified postcondition: ((New_hsCount == Old_hsCount && New_x == Old_x && New_Ret && Old_hsContainsX && New_hsContainsX) || ((!(New_Ret)) && (!(Old_hsContainsX)) && (!(New_hsContainsX)) && Old_x == Old_hsCount && Old_x == New_hsCount && New_x == New_hsCount) || (New_hsCount == Old_hsCount && New_x == Old_x && (!(New_Ret)) && (!(Old_hsContainsX)) && (!(New_hsContainsX)) && (!(New_x == New_hsCount))))

predicates: New_hsContainsX

Any: Pass

L: Pass

SubL: Pass

---------------------