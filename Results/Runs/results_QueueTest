Problem: QueueTest

PUT: PUT_EnqueueContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == 0 && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top)

unsimplified post:
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == 0 && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

unsimplified post:
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

===== Final Result for PUT_EnqueueContract

postcondition k == 0
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)
rounds: 3

simplified post k == 0
((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && New_x == Old_x))
pex time: 283.7807548046112

learn time: 7.873165845870972

Samples: 19

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == 0 && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : Old_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left:  for k = 1 : (New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == 0 && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top) && (((New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top) && Old_s1ContainsX) || (true && (!(Old_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : New_x == Old_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left:  for k = 1 : (New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)
Houdini AlwaysTrue for k=0 : ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root Right:  for k = 1 : ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && (((New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && New_x == Old_Top) || (((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (!(New_x == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : New_x == Old_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left:  for k = 1 : (New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)
Houdini AlwaysTrue for k=0 : ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root Right:  for k = 1 : ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && (((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && New_x == Old_Top) || (((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (!(New_x == Old_Top)))))

#############
Round: 4

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: (Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: (Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : New_x == Old_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left:  for k = 1 : (New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)
Houdini AlwaysTrue for k=0 : (Old_x != Old_Top && New_x != Old_Top)

root Right:  for k = 1 : (Old_x != Old_Top && New_x != Old_Top)
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && (((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && New_x == Old_Top) || ((Old_x != Old_Top && New_x != Old_Top) && (!(New_x == Old_Top)))))

===== Final Result for PUT_EnqueueContract

postcondition k == 1
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && (((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && New_x == Old_Top) || ((Old_x != Old_Top && New_x != Old_Top) && (!(New_x == Old_Top)))))
rounds: 5

simplified post k == 1
((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && New_x == Old_x && New_x == New_Top) || (New_s1ContainsX && New_s1Count == 1 + Old_s1Count && New_x == Old_x && (!(New_x == Old_Top))))
pex time: 540.9970054626465

learn time: 150.46249389648438

Samples: 42

Not(k0 -> k1)? sat

Not(k1 -> k0)? sat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == 0 && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : Old_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_x == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_x == New_s1Count

called learn3 with 0 feature vectors
root Left Left:  for k = 1 : false
root Left Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Left Right:  for k = 1 : true
root Left:  for k = 2 : ((New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top) && ((false && New_x == New_s1Count) || (true && (!(New_x == New_s1Count)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: Old_x != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_x == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_x != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_x == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: Old_x != New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_x == New_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_x != New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_x == New_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_x == New_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top)

root Right Left:  for k = 1 : (New_s1Count == 1 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top)
Houdini AlwaysTrue for k=0 : (New_x == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root Right Right:  for k = 1 : (New_x == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root Right:  for k = 2 : (true && (((New_s1Count == 1 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top) && New_x == New_Top) || ((New_x == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top) && (!(New_x == New_Top)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == 0 && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top) && ((((New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top) && ((false && New_x == New_s1Count) || (true && (!(New_x == New_s1Count))))) && Old_s1ContainsX) || ((true && (((New_s1Count == 1 &&  New_x == 0 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_x == Old_s1Count &&  New_x == Old_s1Count &&  Old_x == Old_Top &&  New_x == Old_Top &&  Old_x == New_Top) && New_x == New_Top) || ((New_x == 1 &&  Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_x != Old_Top &&  New_x != Old_Top &&  Old_x != New_Top &&  New_x != New_Top) && (!(New_x == New_Top))))) && (!(Old_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : New_x == Old_Top

Houdini AlwaysTrue for k=1 : (New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left implication check-- split pred: Old_s1ContainsX
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: Not(Old_s1ContainsX)
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_x != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: Old_x == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_x != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: New_x == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : Old_s1ContainsX

Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left Left:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left Right:  for k = 1 : (New_s1Count == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left:  for k = 2 : ((New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count) && (!(Old_s1ContainsX)))))
Houdini AlwaysTrue for k=1 : ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_x != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: Old_x == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_x == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right from implication check-- split from pred Old_x == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: Old_x != New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_x == New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_x != New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_x == New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_x == Old_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == 0 && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right Left:  for k = 1 : (New_Top == 0 && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right:  for k = 2 : (((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (((New_Top == 0 && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && New_x == Old_s1Count) || ((New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count) && (!(New_x == Old_s1Count)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && ((((New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_x != Old_s1Count &&  New_x != Old_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_x == Old_s1Count &&  New_x == Old_s1Count) && (!(Old_s1ContainsX))))) && New_x == Old_Top) || ((((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (((New_Top == 0 &&  Old_Top != Old_s1Count &&  Old_x == Old_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && New_x == Old_s1Count) || ((New_Top != Old_s1Count &&  Old_x != Old_s1Count &&  New_x != Old_s1Count &&  Old_Top != New_s1Count) && (!(New_x == Old_s1Count))))) && (!(New_x == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : New_x == Old_Top

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left implication check-- split pred: Old_s1ContainsX
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)))

root Left implication check-- split pred: Not(Old_s1ContainsX)
root Left implication check-- featurePos: ((!(Old_s1ContainsX)))
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_x == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_x == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : Old_s1ContainsX

Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left Left:  for k = 1 : (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (New_s1Count == 1)

root Left Right:  for k = 1 : (New_s1Count == 1)
root Left:  for k = 2 : ((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1) && (!(Old_s1ContainsX)))))
Houdini AlwaysTrue for k=1 : ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: Old_x != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: Old_x == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_x == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right from implication check-- split from pred Old_x == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: Old_x != New_Top
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_x == New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_x != New_Top
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_x == New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_x == Old_s1Count

Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right Left:  for k = 1 : (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right Right:  for k = 1 : (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right:  for k = 2 : (((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (((Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_x != Old_s1Count && New_x != Old_s1Count) && (!(New_x == Old_s1Count)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && ((((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((Old_Top != New_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1) && (!(Old_s1ContainsX))))) && New_x == Old_Top) || ((((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (((Old_Top != Old_s1Count &&  Old_x == Old_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_x != Old_s1Count &&  New_x != Old_s1Count) && (!(New_x == Old_s1Count))))) && (!(New_x == Old_Top)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : New_x == Old_Top

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left implication check-- split pred: Old_s1ContainsX
root Left implication check-- featurePos: (Old_s1ContainsX)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)))

root Left implication check-- split pred: Not(Old_s1ContainsX)
root Left implication check-- featurePos: ((!(Old_s1ContainsX)))
root Left implication check-- featureNeg: (Old_s1ContainsX)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_x == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_x == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_x == Old_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left:  for k = 2 : ((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count) && (!(New_x == Old_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top)

root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: Old_x != New_s1Count
root Right implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: Old_x == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x != New_s1Count
root Right implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_x == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right from implication check-- split from pred Old_x == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: Old_x != New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_x == New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_x != New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_x == New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_x == Old_s1Count

Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && Old_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right Left:  for k = 1 : (Old_Top != Old_s1Count && Old_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right Right:  for k = 1 : (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right:  for k = 2 : (((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (((Old_Top != Old_s1Count && Old_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_x != Old_s1Count && New_x != Old_s1Count) && (!(New_x == Old_s1Count)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && ((((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_x == Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_x != Old_s1Count &&  New_x != Old_s1Count) && (!(New_x == Old_s1Count))))) && New_x == Old_Top) || ((((!(Old_s1ContainsX)) && Old_x != Old_Top && New_x != Old_Top) && (((Old_Top != Old_s1Count &&  Old_x == Old_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_x != Old_s1Count &&  New_x != Old_s1Count) && (!(New_x == Old_s1Count))))) && (!(New_x == Old_Top)))))

#############
Round: 5

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && New_Top == Old_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: (Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: (Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top && Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != New_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root implication check-- split pred: New_x != New_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)
root implication check-- featureNeg: (Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: New_x == New_Top
root implication check-- featurePos: (Old_x == New_Top && New_x == New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x != Old_Top && New_x != Old_Top && Old_x != New_Top && New_x != New_Top)

root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : New_x == Old_Top

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top)

root Left implication check-- split pred: Old_s1ContainsX
root Left implication check-- featurePos: (Old_s1ContainsX)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)))

root Left implication check-- split pred: Not(Old_s1ContainsX)
root Left implication check-- featurePos: ((!(Old_s1ContainsX)))
root Left implication check-- featureNeg: (Old_s1ContainsX)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_x == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_x == New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_x == Old_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left:  for k = 2 : ((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count) && (!(New_x == Old_s1Count)))))
Houdini AlwaysTrue for k=1 : (Old_x != Old_Top && New_x != Old_Top)

root Right implication check-- split pred: Old_s1ContainsX
root Right implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)))

root Right implication check-- split pred: Not(Old_s1ContainsX)
root Right implication check-- featurePos: ((!(Old_s1ContainsX)))
root Right implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: Old_x != New_s1Count
root Right implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: Old_x == New_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x != New_s1Count
root Right implication check-- featurePos: (Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_x == New_s1Count
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right from implication check-- split from pred Old_x == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: Old_x != New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: Old_x == New_Top
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right implication check-- split pred: New_x != New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)

root Right implication check-- split pred: New_x == New_Top
root Right implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top && New_x == New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_x == New_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_Top == Old_x && (!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top)

root Right Left:  for k = 1 : (New_s1Count == 1 && New_Top == Old_x && (!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top)
Houdini AlwaysTrue for k=0 : (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)

root Right Right:  for k = 1 : (New_Top == Old_Top && Old_x != New_Top && New_x != New_Top)
root Right:  for k = 2 : ((Old_x != Old_Top && New_x != Old_Top) && (((New_s1Count == 1 && New_Top == Old_x && (!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x == New_Top) && New_x == New_Top) || ((New_Top == Old_Top && Old_x != New_Top && New_x != New_Top) && (!(New_x == New_Top)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && ((((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_x == Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_x != Old_s1Count &&  New_x != Old_s1Count) && (!(New_x == Old_s1Count))))) && New_x == Old_Top) || (((Old_x != Old_Top && New_x != Old_Top) && (((New_s1Count == 1 &&  New_Top == Old_x &&  (!(Old_s1ContainsX)) &&  New_Top != Old_Top &&  Old_x == New_Top) && New_x == New_Top) || ((New_Top == Old_Top &&  Old_x != New_Top &&  New_x != New_Top) && (!(New_x == New_Top))))) && (!(New_x == Old_Top)))))

===== Final Result for PUT_EnqueueContract

postcondition k == 2
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_x == Old_x && New_s1Count != Old_s1Count) && ((((New_Top == Old_Top && Old_x == Old_Top && Old_x == New_Top && New_x == New_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_x == Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && New_x == Old_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_x != Old_s1Count &&  New_x != Old_s1Count) && (!(New_x == Old_s1Count))))) && New_x == Old_Top) || (((Old_x != Old_Top && New_x != Old_Top) && (((New_s1Count == 1 &&  New_Top == Old_x &&  (!(Old_s1ContainsX)) &&  New_Top != Old_Top &&  Old_x == New_Top) && New_x == New_Top) || ((New_Top == Old_Top &&  Old_x != New_Top &&  New_x != New_Top) && (!(New_x == New_Top))))) && (!(New_x == Old_Top)))))
rounds: 6

simplified post k == 2
((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && New_x == Old_x && New_Top == Old_Top) || (New_s1ContainsX && New_s1Count == 1 + Old_s1Count && New_s1Count == 1 && (!(Old_s1ContainsX)) && Old_x == New_Top && New_x == New_Top) || (New_s1ContainsX && New_s1Count == 1 + Old_s1Count && New_x == Old_x && New_x == New_Top && New_x == Old_Top))
pex time: 501.38022351264954

learn time: 335.0973870754242

Samples: 63

Not(k0 -> k2)? sat

Not(k1 -> k2)? sat

PUT: PUT_DequeueContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

===== Final Result for PUT_DequeueContract

postcondition k == 0
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)
rounds: 3

simplified post k == 0
((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))
pex time: 102.26351809501648

learn time: 5.396644353866577

Samples: 21

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=0 : (New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left:  for k = 1 : (New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count) && (((New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && New_s1ContainsNewRet) || (true && (!(New_s1ContainsNewRet)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=0 : (New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Left:  for k = 1 : (New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && (((New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count) && New_s1ContainsNewRet) || (true && (!(New_s1ContainsNewRet)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root Left:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && (((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count) && New_s1ContainsNewRet) || (true && (!(New_s1ContainsNewRet)))))

#############
Round: 4

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : None

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

===== Final Result for PUT_DequeueContract

postcondition k == 1
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)
rounds: 5

simplified post k == 1
((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))
pex time: 162.7322850227356

learn time: 47.97187638282776

Samples: 42

Not(k0 -> k1)? unsat

Not(k1 -> k0)? unsat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == 0 && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top == 1 && New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top == 1 && New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top == 1 && New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_Top && New_Top == 0 && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == Old_Top && New_Top == 0 && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right Right:  for k = 1 : (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right:  for k = 2 : (true && (((New_s1Count == Old_Top && New_Top == 0 && Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count) && ((((New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top == 1 &&  New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_s1Count == Old_Top &&  New_Top == 0 &&  Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((Old_Top != New_s1Count &&  New_Ret != New_s1Count &&  New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == 0 && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Ret == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right:  for k = 2 : (true && (((New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((New_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count) && (!(New_Ret == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_s1Count == Old_Top &&  Old_Top != Old_s1Count &&  New_Ret != Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Ret != New_s1Count) && (!(New_Ret == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == 0 && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (true && (((New_Top == Old_s1Count - 1 && New_Top != Old_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_Top == Old_s1Count - 1 &&  New_Top != Old_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Ret != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == 0 && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != New_s1Count)
root Right:  for k = 2 : (true && (((New_Top == Old_s1Count - 1 && New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_Top == Old_s1Count - 1 &&  New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 5

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Ret == 0 && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == 0 && New_Ret == 0 && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Ret == 0 && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != New_s1Count)
root Right:  for k = 2 : (true && (((New_Top == Old_s1Count - 1 && New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 &&  New_Ret == 0 &&  New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_Top == Old_s1Count - 1 &&  New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 6

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != New_s1Count)
root Right:  for k = 2 : (true && (((New_Top == Old_s1Count - 1 && New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_Top == Old_s1Count - 1 &&  New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 7

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left implication check-- split pred: New_Ret != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_s1Count
root Left implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count) && (((New_Top == Old_Top) && New_Ret == New_Top) || ((Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != New_s1Count)
root Right:  for k = 2 : (true && (((New_Top == Old_s1Count - 1 && New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count) && (((New_Top == Old_Top) && New_Ret == New_Top) || ((Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != New_s1Count &&  New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_Top == Old_s1Count - 1 &&  New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 8

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_s1ContainsNewRet)) && Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_s1ContainsNewRet

Houdini AlwaysTrue for k=1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == New_s1Count && New_Ret == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == New_s1Count && New_Ret == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != New_s1Count)

root Left implication check-- split pred: New_Ret != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == New_s1Count && New_Ret == New_s1Count)

root Left implication check-- split pred: New_Ret == New_s1Count
root Left implication check-- featurePos: (Old_Top == New_s1Count && New_Ret == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count) && (((New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != New_s1Count)
root Right:  for k = 2 : (true && (((New_Top == Old_s1Count - 1 && New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count) && (((New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != New_s1Count &&  New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_s1ContainsNewRet) || ((true && (((New_Top == Old_s1Count - 1 &&  New_Top != Old_s1Count) && New_Top == New_s1Count) || ((New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsNewRet)))))

#############
Round: 9

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_s1ContainsNewRet
root implication check-- featurePos: (New_s1ContainsNewRet)
root implication check-- featureNeg: ((!(New_s1ContainsNewRet)))

root implication check-- split pred: Not(New_s1ContainsNewRet)
root implication check-- featurePos: ((!(New_s1ContainsNewRet)))
root implication check-- featureNeg: (New_s1ContainsNewRet)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : None

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

===== Final Result for PUT_DequeueContract

postcondition k == 2
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)
rounds: 10

simplified post k == 2
((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))
pex time: 428.24757504463196

learn time: 467.0613193511963

Samples: 107

Not(k0 -> k2)? unsat

Not(k1 -> k2)? unsat

PUT: PUT_PeekContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == 0 && New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

unsimplified post:
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == 0 && New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

unsimplified post:
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

===== Final Result for PUT_PeekContract

postcondition k == 0
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
rounds: 3

simplified post k == 0
((New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
pex time: 141.20011806488037

learn time: 5.85175633430481

Samples: 10

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == 0 && New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_s1ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 1 : None

unsimplified post:
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == 0 && New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_s1ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 1 : None

unsimplified post:
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

===== Final Result for PUT_PeekContract

postcondition k == 1
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
rounds: 3

simplified post k == 1
((New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
pex time: 126.77026438713074

learn time: 12.228354454040527

Samples: 10

Not(k0 -> k1)? unsat

Not(k1 -> k0)? unsat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == 0 && New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_s1ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 2 : None

unsimplified post:
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == 0 && New_Ret == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_s1ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 2 : None

unsimplified post:
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

===== Final Result for PUT_PeekContract

postcondition k == 2
(New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
rounds: 3

simplified post k == 2
((New_s1ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
pex time: 137.28325986862183

learn time: 12.234037160873413

Samples: 10

Not(k0 -> k2)? unsat

Not(k1 -> k2)? unsat

PUT: PUT_CountContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

===== Final Result for PUT_CountContract

postcondition k == 0
(New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)
rounds: 3

simplified post k == 0
((New_Ret == Old_s1Count && New_Ret == New_s1Count))
pex time: 284.1063938140869

learn time: 6.53950309753418

Samples: 18

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right:  for k = 1 : (New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || ((New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 1 : New_Ret == Old_Top

Houdini AlwaysTrue for k=0 : (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Left:  for k = 1 : (Old_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right:  for k = 1 : (New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((Old_Top == Old_s1Count && Old_Top == New_s1Count) && New_Ret == Old_Top) || ((New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 1 : New_ContainsNewRet

Houdini AlwaysTrue for k=0 : (New_Top == Old_Top)

root Left:  for k = 1 : (New_Top == Old_Top)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_Top) && New_ContainsNewRet) || (true && (!(New_ContainsNewRet)))))

===== Final Result for PUT_CountContract

postcondition k == 1
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_Top) && New_ContainsNewRet) || (true && (!(New_ContainsNewRet)))))
rounds: 4

simplified post k == 1
((New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Top == Old_Top) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && (!(New_ContainsNewRet))))
pex time: 420.94686245918274

learn time: 62.693881034851074

Samples: 29

Not(k0 -> k1)? sat

Not(k1 -> k0)? sat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_Ret == New_Top

Houdini AlwaysTrue for k=1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left implication check-- split pred: New_ContainsNewRet
root Left implication check-- featurePos: (New_ContainsNewRet)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)))

root Left implication check-- split pred: Not(New_ContainsNewRet)
root Left implication check-- featurePos: ((!(New_ContainsNewRet)))
root Left implication check-- featureNeg: (New_ContainsNewRet)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : None

root Left:  for k = 2 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=1 : (New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_ContainsNewRet: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_ContainsNewRet: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret == Old_Top: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_Top != Old_Top

called learn3 with 0 feature vectors
root Right Left:  for k = 1 : false
root Right Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right Right:  for k = 1 : true
root Right:  for k = 2 : ((New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || (((New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top))))) && (!(New_Ret == New_Top)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 2 : New_Ret == Old_Top

Houdini AlwaysTrue for k=1 : (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Left implication check-- split pred: New_ContainsNewRet
root Left implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)))

root Left implication check-- split pred: Not(New_ContainsNewRet)
root Left implication check-- featurePos: ((!(New_ContainsNewRet)))
root Left implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_ContainsNewRet

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Ret == 0)

root Left Right:  for k = 1 : (New_s1Count == 0 && New_Ret == 0)
root Left:  for k = 2 : ((Old_Top == Old_s1Count && Old_Top == New_s1Count) && (((New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top) && New_ContainsNewRet) || ((New_s1Count == 0 && New_Ret == 0) && (!(New_ContainsNewRet)))))
Houdini AlwaysTrue for k=1 : (New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_ContainsNewRet
root Right implication check-- featurePos: (New_ContainsNewRet)
root Right implication check-- featureNeg: ((!(New_ContainsNewRet)))

root Right implication check-- split pred: Not(New_ContainsNewRet)
root Right implication check-- featurePos: ((!(New_ContainsNewRet)))
root Right implication check-- featureNeg: (New_ContainsNewRet)

root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret == New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret == New_Top: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_Ret != New_s1Count

called learn3 with 0 feature vectors
root Right Left:  for k = 1 : false
root Right Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right Right:  for k = 1 : true
root Right:  for k = 2 : ((New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Ret != New_s1Count) || (true && (!(New_Ret != New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((Old_Top == Old_s1Count && Old_Top == New_s1Count) && (((New_Top == Old_s1Count &&  New_Top == New_s1Count &&  New_Top == Old_Top &&  New_Ret == New_Top) && New_ContainsNewRet) || ((New_s1Count == 0 && New_Ret == 0) && (!(New_ContainsNewRet))))) && New_Ret == Old_Top) || (((New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Ret != New_s1Count) || (true && (!(New_Ret != New_s1Count))))) && (!(New_Ret == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 2 : New_ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != Old_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == Old_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Top == Old_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || ((New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

root Right implication check-- split pred: New_Ret != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: New_Ret == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == Old_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right Right:  for k = 1 : (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right:  for k = 2 : (true && (((New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top) && (!(New_Ret == Old_Top)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == Old_Top) && New_Ret == New_Top) || ((New_Top == 0 &&  Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == 0 &&  New_Ret == 0 &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Ret != Old_Top) && (!(New_Ret == Old_Top))))) && (!(New_ContainsNewRet)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 2 : New_ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != Old_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == Old_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Top == Old_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

root Right implication check-- split pred: New_Ret != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: New_Ret == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == Old_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right Right:  for k = 1 : (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right:  for k = 2 : (true && (((New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top) && (!(New_Ret == Old_Top)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == Old_Top) && New_Ret == New_Top) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == 0 &&  New_Ret == 0 &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Ret != Old_Top) && (!(New_Ret == Old_Top))))) && (!(New_ContainsNewRet)))))

===== Final Result for PUT_CountContract

postcondition k == 2
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == Old_Top) && New_Ret == New_Top) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == 0 &&  New_Ret == 0 &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Ret != Old_Top) && (!(New_Ret == Old_Top))))) && (!(New_ContainsNewRet)))))
rounds: 5

simplified post k == 2
((New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_ContainsNewRet) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Ret == 0 && (!(New_ContainsNewRet))) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && (!(New_Ret == Old_Top)) && (!(New_ContainsNewRet))))
pex time: 541.291797876358

learn time: 179.98232746124268

Samples: 41

Not(k0 -> k2)? sat

Not(k1 -> k2)? sat

PUT: PUT_ContainsContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

unsimplified post:
(New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count)

===== Final Result for PUT_ContainsContract

postcondition k == 0
(New_s1Count == Old_s1Count)
rounds: 3

simplified post k == 0
((New_s1Count == Old_s1Count))
pex time: 150.34033751487732

learn time: 6.134100675582886

Samples: 17

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root for k = 1 : New_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Ret && Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left:  for k = 1 : (New_Ret && Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
Houdini AlwaysTrue for k=0 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right:  for k = 1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top) && (((New_Ret && Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 1 : New_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root Left:  for k = 1 : (New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right:  for k = 1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))
unsimplified post:
((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 1 : New_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left:  for k = 1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
Houdini AlwaysTrue for k=0 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right:  for k = 1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))
unsimplified post:
((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

#############
Round: 4

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 1 : New_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)

root Left:  for k = 1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right:  for k = 1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))
unsimplified post:
((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

===== Final Result for PUT_ContainsContract

postcondition k == 1
((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))
rounds: 5

simplified post k == 1
((New_s1Count == Old_s1Count && New_Ret && Old_s1ContainsX && New_Top == Old_Top && New_s1ContainsX) || (New_s1Count == Old_s1Count && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX))))
pex time: 219.77921056747437

learn time: 80.59139347076416

Samples: 30

Not(k0 -> k1)? sat

Not(k1 -> k0)? sat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_Top != Old_Top

called learn3 with 0 feature vectors
root Left Left:  for k = 1 : false
root Left Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Left Right:  for k = 1 : true
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top) && ((((New_Ret && Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_s1Count != Old_s1Count

called learn3 with 0 feature vectors
root Left Left:  for k = 1 : false
root Left Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Left Right:  for k = 1 : true
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && ((false && New_s1Count != Old_s1Count) || (true && (!(New_s1Count != Old_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Top == 0 && New_Top == Old_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && New_Top == 0 && New_Top == Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 && New_Top == 0 && New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && ((false && New_s1Count != Old_s1Count) || (true && (!(New_s1Count != Old_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 &&  New_Top == 0 &&  New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_s1Count != Old_s1Count

called learn3 with 0 feature vectors
root Left Left:  for k = 1 : false
root Left Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Left Right:  for k = 1 : true
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && ((false && New_s1Count != Old_s1Count) || (true && (!(New_s1Count != Old_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

Predicate: root Right for k = 1 : Old_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (Old_Top == Old_s1Count)

root Right Left:  for k = 1 : (Old_Top == Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top == 0 && Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top == 0 && Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((Old_Top == Old_s1Count) && Old_Top == New_s1Count) || ((New_Top == 0 && Old_Top != Old_s1Count && Old_Top != New_s1Count) && (!(Old_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && ((false && New_s1Count != Old_s1Count) || (true && (!(New_s1Count != Old_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((Old_Top == Old_s1Count) && Old_Top == New_s1Count) || ((New_Top == 0 &&  Old_Top != Old_s1Count &&  Old_Top != New_s1Count) && (!(Old_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

===== Final Result for PUT_ContainsContract

postcondition k == 2
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))
rounds: 5

simplified post k == 2
((New_s1Count == Old_s1Count && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX))) || (New_s1Count == Old_s1Count && New_Ret && Old_s1ContainsX && New_Top == Old_Top && New_s1ContainsX))
pex time: 200.3343584537506

learn time: 133.77983021736145

Samples: 40

Not(k0 -> k2)? sat

Not(k1 -> k2)? unsat

