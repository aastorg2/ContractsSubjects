Problem: StackTest

PUT: PUT_PushContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

unsimplified post:
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

unsimplified post:
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

===== Final Result for PUT_PushContract

postcondition k == 0
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)
rounds: 3

simplified post k == 0
((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))
pex time: 188.06009721755981

learn time: 8.839656591415405

Samples: 15

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : Old_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root Left:  for k = 1 : (New_Top == 0 && New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top) && (((New_Top == 0 && New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top) && Old_s1ContainsX) || (true && (!(Old_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : New_x == Old_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top)

root Left:  for k = 1 : (New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right:  for k = 1 : (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top) && (((New_Top == 0 && New_x == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top) && New_x == Old_Top) || ((New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top) && (!(New_x == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : New_x == Old_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && (!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left:  for k = 1 : (New_Top == Old_s1Count && (!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Right:  for k = 1 : (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top) && (((New_Top == Old_s1Count && (!(Old_s1ContainsX)) && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && New_x == Old_s1Count) || ((New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count) && (!(New_x == Old_s1Count)))))

#############
Round: 4

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : Old_s1ContainsX

Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left:  for k = 1 : (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top) && (((Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && Old_s1ContainsX) || (true && (!(Old_s1ContainsX)))))

#############
Round: 5

Houdini AlwaysTrue for k=1 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 1 : None

unsimplified post:
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

===== Final Result for PUT_PushContract

postcondition k == 1
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)
rounds: 6

simplified post k == 1
((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))
pex time: 290.4679591655731

learn time: 98.27935433387756

Samples: 40

Not(k0 -> k1)? unsat

Not(k1 -> k0)? unsat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : Old_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Top == 0 && New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_x == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_x == New_s1Count

called learn3 with 0 feature vectors
root Left Left:  for k = 1 : false
root Left Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Left Right:  for k = 1 : true
root Left:  for k = 2 : ((New_Top == 0 && New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top) && ((false && New_x == New_s1Count) || (true && (!(New_x == New_s1Count)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right implication check-- split pred: Old_x != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root Right implication check-- split pred: Old_x == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right implication check-- split pred: New_x != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root Right implication check-- split pred: New_x == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_x == Old_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_Top == 0 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top)

root Right Left:  for k = 1 : (New_s1Count == 1 && New_Top == 0 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top == 1 && New_x == 1 && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right Right:  for k = 1 : (New_Top == 1 && New_x == 1 && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root Right:  for k = 2 : (true && (((New_s1Count == 1 && New_Top == 0 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top == Old_Top && Old_x == Old_Top) && New_x == Old_Top) || ((New_Top == 1 && New_x == 1 && Old_Top != Old_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top) && (!(New_x == Old_Top)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == New_Top && New_x == New_Top) && ((((New_Top == 0 && New_x == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top) && ((false && New_x == New_s1Count) || (true && (!(New_x == New_s1Count))))) && Old_s1ContainsX) || ((true && (((New_s1Count == 1 &&  New_Top == 0 &&  New_x == 0 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_x == Old_s1Count &&  New_x == Old_s1Count &&  New_Top == Old_Top &&  Old_x == Old_Top) && New_x == Old_Top) || ((New_Top == 1 &&  New_x == 1 &&  Old_Top != Old_s1Count &&  New_Top != Old_Top &&  Old_x != Old_Top &&  New_x != Old_Top) && (!(New_x == Old_Top))))) && (!(Old_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : New_x == Old_Top

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == Old_Top)

root Left implication check-- split pred: Old_s1ContainsX
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: Not(Old_s1ContainsX)
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_x != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: Old_x == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_x != Old_s1Count
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left implication check-- split pred: New_x == Old_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_x == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : Old_s1ContainsX

Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left Left:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_Top == 0 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)

root Left Right:  for k = 1 : (New_s1Count == 1 && New_Top == 0 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count)
root Left:  for k = 2 : ((New_Top == Old_Top && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == Old_Top) && (((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1 && New_Top == 0 && New_x == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count) && (!(Old_s1ContainsX)))))
Houdini AlwaysTrue for k=1 : ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: Old_x == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_x == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right from implication check-- split from pred New_Top == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred Old_x == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_x == Old_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right:  for k = 2 : (((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top) && (((New_Top == Old_s1Count && Old_Top != Old_s1Count && Old_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && New_x == Old_s1Count) || ((New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count) && (!(New_x == Old_s1Count)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top) && ((((New_Top == Old_Top && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && Old_x == Old_Top) && (((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_x != Old_s1Count &&  New_x != Old_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1 &&  New_Top == 0 &&  New_x == 0 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_x == Old_s1Count &&  New_x == Old_s1Count) && (!(Old_s1ContainsX))))) && New_x == Old_Top) || ((((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top) && (((New_Top == Old_s1Count &&  Old_Top != Old_s1Count &&  Old_x == Old_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && New_x == Old_s1Count) || ((New_Top != Old_s1Count &&  Old_x != Old_s1Count &&  New_x != Old_s1Count &&  Old_Top != New_s1Count) && (!(New_x == Old_s1Count))))) && (!(New_x == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count && New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : New_x == Old_Top

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top && Old_x == Old_Top)

root Left implication check-- split pred: Old_s1ContainsX
root Left implication check-- featurePos: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)))

root Left implication check-- split pred: Not(Old_s1ContainsX)
root Left implication check-- featurePos: ((!(Old_s1ContainsX)))
root Left implication check-- featureNeg: (Old_s1ContainsX && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: New_x != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: Old_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: Old_x == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left implication check-- split pred: New_x != New_s1Count
root Left implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Left implication check-- featureNeg: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Left implication check-- split pred: New_x == New_s1Count
root Left implication check-- featurePos: ((!(Old_s1ContainsX)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Left for k = 1 : Old_s1ContainsX

Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Left Left:  for k = 1 : (Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (New_s1Count == 1)

root Left Right:  for k = 1 : (New_s1Count == 1)
root Left:  for k = 2 : ((New_Top == Old_Top && Old_x == Old_Top) && (((Old_Top != New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1) && (!(Old_s1ContainsX)))))
Houdini AlwaysTrue for k=1 : ((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: Old_x != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: New_x != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: Old_x != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: Old_x == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right implication check-- split pred: New_x != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root Right implication check-- split pred: New_x == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root Right implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right from implication check-- split from pred New_Top == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred Old_x == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x == Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root Right for k = 1 : Old_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count)

root Right Right:  for k = 1 : (Old_Top != New_s1Count)
root Right:  for k = 2 : (((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top) && (((New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count) && Old_Top == New_s1Count) || ((Old_Top != New_s1Count) && (!(Old_Top == New_s1Count)))))
unsimplified post:
((New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top) && ((((New_Top == Old_Top && Old_x == Old_Top) && (((Old_Top != New_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && Old_s1ContainsX) || ((New_s1Count == 1) && (!(Old_s1ContainsX))))) && New_x == Old_Top) || ((((!(Old_s1ContainsX)) && New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top) && (((New_s1Count == Old_Top &&  Old_Top != Old_s1Count &&  New_Top != New_s1Count &&  Old_x != New_s1Count &&  New_x != New_s1Count) && Old_Top == New_s1Count) || ((Old_Top != New_s1Count) && (!(Old_Top == New_s1Count))))) && (!(New_x == Old_Top)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (Old_s1ContainsX)
root implication check-- featureNeg: ((!(Old_s1ContainsX)))

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(Old_s1ContainsX)))
root implication check-- featureNeg: (Old_s1ContainsX)

root from implication check-- split from pred Not(New_s1ContainsX): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_s1ContainsX): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: New_x != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && Old_x == Old_s1Count && New_x == Old_s1Count && New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: Old_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: Old_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_x != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)

root implication check-- split pred: New_x == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && Old_x != Old_s1Count && New_x != Old_s1Count && New_Top == New_s1Count && Old_x == New_s1Count && New_x == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count && Old_x != New_s1Count && New_x != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: Old_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: Old_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root implication check-- split pred: New_x != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)

root implication check-- split pred: New_x == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && Old_x == Old_Top && New_x == Old_Top)
root implication check-- featureNeg: (New_Top != Old_Top && Old_x != Old_Top && New_x != Old_Top)

root from implication check-- split from pred Old_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != New_Top: not expressive in with conjunctions
root from implication check-- split from pred New_x != Old_x: houdini Called with 0 feature vectors
root from implication check-- split from pred New_x != Old_x: not expressive in with conjunctions
Predicate: root for k = 2 : None

unsimplified post:
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)

===== Final Result for PUT_PushContract

postcondition k == 2
(New_s1ContainsX && New_s1Count == Old_s1Count + 1 && New_Top == Old_x && New_x == Old_x && New_s1Count != Old_s1Count && Old_x == New_Top && New_x == New_Top)
rounds: 5

simplified post k == 2
((New_s1ContainsX && New_s1Count == 1 + Old_s1Count && Old_x == New_Top && New_x == New_Top))
pex time: 227.7580122947693

learn time: 124.54550075531006

Samples: 39

Not(k0 -> k2)? unsat

Not(k1 -> k2)? unsat

PUT: PUT_PopContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Ret != Old_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Ret != Old_s1Count)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

===== Final Result for PUT_PopContract

postcondition k == 0
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)
rounds: 3

simplified post k == 0
((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))
pex time: 173.25807428359985

learn time: 5.807610988616943

Samples: 13

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count)

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count)
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_ContainsNewRet

Houdini AlwaysTrue for k=0 : (New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left:  for k = 1 : (New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Top != Old_s1Count)

root Right:  for k = 1 : (New_Top == 0 && New_Top != Old_s1Count)
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Ret != Old_s1Count) && (((New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && New_ContainsNewRet) || ((New_Top == 0 && New_Top != Old_s1Count) && (!(New_ContainsNewRet)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)

root Left:  for k = 1 : (New_Top == Old_s1Count - 1 && New_Top != Old_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root Right:  for k = 1 : (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && (((New_Top == Old_s1Count - 1 && New_Top != Old_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_ContainsNewRet

Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Left:  for k = 1 : (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && (((Old_Top != New_s1Count && New_Ret != New_s1Count) && New_ContainsNewRet) || (true && (!(New_ContainsNewRet)))))

#############
Round: 4

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : None

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

===== Final Result for PUT_PopContract

postcondition k == 1
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)
rounds: 5

simplified post k == 1
((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))
pex time: 241.97832465171814

learn time: 50.21434569358826

Samples: 27

Not(k0 -> k1)? unsat

Not(k1 -> k0)? unsat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count)

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count)
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_Top == 0 && New_Top != Old_s1Count && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_s1Count == 1 && New_Top == 0 && New_Top != Old_s1Count && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_s1Count == 1 && New_Top == 0 && New_Top != Old_s1Count && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top == Old_s1Count && New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
Houdini AlwaysTrue for k=1 : (New_Top == 0 && New_Top != Old_s1Count)

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top)

root Right Left:  for k = 1 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Ret == 1 && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right Right:  for k = 1 : (New_Ret == 1 && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right:  for k = 2 : ((New_Top == 0 && New_Top != Old_s1Count) && (((New_s1Count == 0 && New_Ret == 0 && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Ret == 1 && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count && Old_Top != Old_s1Count && New_Ret != Old_s1Count) && ((((New_Ret == 0 && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count) && (((New_s1Count == 1 &&  New_Top == 0 &&  New_Top != Old_s1Count &&  New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top == Old_s1Count &&  New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || (((New_Top == 0 && New_Top != Old_s1Count) && (((New_s1Count == 0 &&  New_Ret == 0 &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == New_s1Count &&  New_Top == Old_Top) && New_Ret == New_Top) || ((New_Ret == 1 &&  New_Top != New_s1Count &&  New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && (!(New_ContainsNewRet)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Ret == 0 && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (New_Top != Old_s1Count)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count)

root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (New_Top != New_s1Count)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != New_s1Count)

root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == 0 && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Ret == 0 && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right Right:  for k = 1 : (Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right:  for k = 2 : (true && (((New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((Old_Top != New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((New_Ret == 0 && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 &&  New_Top != Old_s1Count &&  New_Top != New_s1Count &&  New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == Old_Top &&  Old_Top != Old_s1Count &&  New_Ret != Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((Old_Top != New_s1Count &&  New_Ret != New_s1Count &&  New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_s1Count))))) && (!(New_ContainsNewRet)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_ContainsNewRet

Houdini AlwaysTrue for k=1 : (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root Left from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (New_Top != Old_s1Count)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count)

root Left from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (New_Top != New_s1Count)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != New_s1Count)

root Left from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == 0 && New_Ret == 0 && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root Left Left:  for k = 1 : (New_Top == 0 && New_Ret == 0 && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 && New_Ret == 0 && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top == Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count)

root Right implication check-- split pred: New_Ret != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_Ret == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top != Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Top == New_s1Count && New_Ret != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Ret != New_s1Count
root Right implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root Right implication check-- split pred: New_Ret == New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != New_s1Count && New_Ret != New_s1Count)

root Right Right:  for k = 1 : (Old_Top != New_s1Count && New_Ret != New_s1Count)
root Right:  for k = 2 : (true && (((New_s1Count == Old_Top && Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((Old_Top != New_s1Count && New_Ret != New_s1Count) && (!(New_Ret == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count) && ((((Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count) && (((New_Top == 0 &&  New_Ret == 0 &&  New_Top != Old_s1Count &&  New_Top != New_s1Count &&  New_Top == Old_Top) && New_Ret == New_Top) || ((New_Top != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == Old_Top &&  Old_Top != Old_s1Count &&  New_Ret != Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == New_s1Count) || ((Old_Top != New_s1Count &&  New_Ret != New_s1Count) && (!(New_Ret == New_s1Count))))) && (!(New_ContainsNewRet)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet)

root from implication check-- split from pred New_s1Count == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count == Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : None

unsimplified post:
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)

===== Final Result for PUT_PopContract

postcondition k == 2
(New_s1Count == Old_s1Count - 1 && New_Ret == Old_Top && New_s1Count != Old_s1Count)
rounds: 5

simplified post k == 2
((New_s1Count == -1 + Old_s1Count && New_Ret == Old_Top))
pex time: 205.8227915763855

learn time: 98.97769618034363

Samples: 35

Not(k0 -> k2)? unsat

Not(k1 -> k2)? unsat

PUT: PUT_PeekContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_ContainsNewRet && New_s1Count == 1 && New_Top == 0 && New_Ret == 0 && New_s1Count == Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

unsimplified post:
(New_ContainsNewRet && New_s1Count == 1 && New_Top == 0 && New_Ret == 0 && New_s1Count == Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

unsimplified post:
(New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

===== Final Result for PUT_PeekContract

postcondition k == 0
(New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
rounds: 3

simplified post k == 0
((New_ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
pex time: 83.65795040130615

learn time: 4.1249167919158936

Samples: 5

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_ContainsNewRet && New_s1Count == 1 && New_Top == 0 && New_Ret == 0 && New_s1Count == Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 1 : None

unsimplified post:
(New_ContainsNewRet && New_s1Count == 1 && New_Top == 0 && New_Ret == 0 && New_s1Count == Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 1 : None

unsimplified post:
(New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

===== Final Result for PUT_PeekContract

postcondition k == 1
(New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
rounds: 3

simplified post k == 1
((New_ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
pex time: 69.37940764427185

learn time: 8.070827960968018

Samples: 5

Not(k0 -> k1)? unsat

Not(k1 -> k0)? unsat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_ContainsNewRet && New_s1Count == 1 && New_Top == 0 && New_Ret == 0 && New_s1Count == Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == Old_s1Count: not expressive in with conjunctions
root from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Ret == New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret == New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 2 : None

unsimplified post:
(New_ContainsNewRet && New_s1Count == 1 && New_Top == 0 && New_Ret == 0 && New_s1Count == Old_s1Count && Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred Not(New_ContainsNewRet): houdini Called with 0 feature vectors
root from implication check-- split from pred Not(New_ContainsNewRet): not expressive in with conjunctions
root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root implication check-- split pred: New_Ret != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_Ret == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && New_Ret == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && New_Ret != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root for k = 2 : None

unsimplified post:
(New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

===== Final Result for PUT_PeekContract

postcondition k == 2
(New_ContainsNewRet && New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
rounds: 3

simplified post k == 2
((New_ContainsNewRet && New_s1Count == Old_s1Count && New_Ret == Old_Top && New_Ret == New_Top))
pex time: 70.06848120689392

learn time: 7.068064451217651

Samples: 5

Not(k0 -> k2)? unsat

Not(k1 -> k2)? unsat

PUT: PUT_CountContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

===== Final Result for PUT_CountContract

postcondition k == 0
(New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)
rounds: 3

simplified post k == 0
((New_Ret == Old_s1Count && New_Ret == New_s1Count))
pex time: 143.24628162384033

learn time: 4.339052438735962

Samples: 9

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right:  for k = 1 : (New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || ((New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 1 : New_Ret == Old_Top

Houdini AlwaysTrue for k=0 : (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Left:  for k = 1 : (Old_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right:  for k = 1 : (New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((Old_Top == Old_s1Count && Old_Top == New_s1Count) && New_Ret == Old_Top) || ((New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 1 : New_ContainsNewRet

Houdini AlwaysTrue for k=0 : (New_Top == Old_Top)

root Left:  for k = 1 : (New_Top == Old_Top)
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right:  for k = 1 : true
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_Top) && New_ContainsNewRet) || (true && (!(New_ContainsNewRet)))))

===== Final Result for PUT_CountContract

postcondition k == 1
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_Top) && New_ContainsNewRet) || (true && (!(New_ContainsNewRet)))))
rounds: 4

simplified post k == 1
((New_Ret == Old_s1Count && New_Ret == New_s1Count && (!(New_ContainsNewRet))) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Top == Old_Top))
pex time: 197.1419277191162

learn time: 31.862207889556885

Samples: 18

Not(k0 -> k1)? sat

Not(k1 -> k0)? sat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root for k = 2 : New_Ret == New_Top

Houdini AlwaysTrue for k=1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left implication check-- split pred: New_ContainsNewRet
root Left implication check-- featurePos: (New_ContainsNewRet)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)))

root Left implication check-- split pred: Not(New_ContainsNewRet)
root Left implication check-- featurePos: ((!(New_ContainsNewRet)))
root Left implication check-- featureNeg: (New_ContainsNewRet)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left from implication check-- split from pred New_Ret != New_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : None

root Left:  for k = 2 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=1 : (New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right from implication check-- split from pred New_ContainsNewRet: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_ContainsNewRet: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret == Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret == Old_Top: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_Top != Old_Top

called learn3 with 0 feature vectors
root Right Left:  for k = 1 : false
root Right Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right Right:  for k = 1 : true
root Right:  for k = 2 : ((New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == Old_Top && New_Ret == Old_s1Count && New_Ret == New_s1Count) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || (((New_Top == 0 && (!(New_ContainsNewRet)) && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top))))) && (!(New_Ret == New_Top)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && Old_Top == Old_s1Count && New_Top != Old_s1Count && Old_Top == New_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret == Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top && New_Ret != Old_Top && New_Ret != New_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == Old_Top && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 2 : New_Ret == Old_Top

Houdini AlwaysTrue for k=1 : (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Left implication check-- split pred: New_ContainsNewRet
root Left implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)))

root Left implication check-- split pred: Not(New_ContainsNewRet)
root Left implication check-- featurePos: ((!(New_ContainsNewRet)))
root Left implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top != New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: New_Top != Old_Top
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_Top
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_s1Count && New_Top != New_s1Count && New_Top != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_ContainsNewRet

Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_Top == 1 && New_Ret == 1 && New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)

root Left Left:  for k = 1 : (New_s1Count == 1 && New_Top == 1 && New_Ret == 1 && New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top)
Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Ret == 0)

root Left Right:  for k = 1 : (New_s1Count == 0 && New_Ret == 0)
root Left:  for k = 2 : ((Old_Top == Old_s1Count && Old_Top == New_s1Count) && (((New_s1Count == 1 && New_Top == 1 && New_Ret == 1 && New_Top == Old_s1Count && New_Top == New_s1Count && New_Top == Old_Top && New_Ret == New_Top) && New_ContainsNewRet) || ((New_s1Count == 0 && New_Ret == 0) && (!(New_ContainsNewRet)))))
Houdini AlwaysTrue for k=1 : (New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Right implication check-- split pred: New_ContainsNewRet
root Right implication check-- featurePos: (New_ContainsNewRet)
root Right implication check-- featureNeg: ((!(New_ContainsNewRet)))

root Right implication check-- split pred: Not(New_ContainsNewRet)
root Right implication check-- featurePos: ((!(New_ContainsNewRet)))
root Right implication check-- featureNeg: (New_ContainsNewRet)

root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Right from implication check-- split from pred New_Ret == New_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret == New_Top: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_Ret != New_s1Count

called learn3 with 0 feature vectors
root Right Left:  for k = 1 : false
root Right Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Right Right:  for k = 1 : true
root Right:  for k = 2 : ((New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Ret != New_s1Count) || (true && (!(New_Ret != New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((Old_Top == Old_s1Count && Old_Top == New_s1Count) && (((New_s1Count == 1 &&  New_Top == 1 &&  New_Ret == 1 &&  New_Top == Old_s1Count &&  New_Top == New_s1Count &&  New_Top == Old_Top &&  New_Ret == New_Top) && New_ContainsNewRet) || ((New_s1Count == 0 && New_Ret == 0) && (!(New_ContainsNewRet))))) && New_Ret == Old_Top) || (((New_Top == Old_Top && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && ((false && New_Ret != New_s1Count) || (true && (!(New_Ret != New_s1Count))))) && (!(New_Ret == Old_Top)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 2 : New_ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != Old_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == Old_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=0 : (New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Top == Old_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || ((New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

root Right implication check-- split pred: New_Ret != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: New_Ret == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Top == 0 && New_Ret == 0 && New_Top == Old_s1Count && New_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && New_Top == 0 && New_Ret == 0 && New_Top == Old_s1Count && New_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right:  for k = 2 : (true && (((New_s1Count == 0 && New_Top == 0 && New_Ret == 0 && New_Top == Old_s1Count && New_Top == New_s1Count) && New_Ret == New_Top) || ((New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == Old_Top) && New_Ret == New_Top) || ((New_Top == 0 &&  Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == 0 &&  New_Top == 0 &&  New_Ret == 0 &&  New_Top == Old_s1Count &&  New_Top == New_s1Count) && New_Ret == New_Top) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && (!(New_ContainsNewRet)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count)

root implication check-- split pred: New_ContainsNewRet
root implication check-- featurePos: (New_ContainsNewRet && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)))

root implication check-- split pred: Not(New_ContainsNewRet)
root implication check-- featurePos: ((!(New_ContainsNewRet)))
root implication check-- featureNeg: (New_ContainsNewRet && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_ContainsNewRet)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_ContainsNewRet)) && New_Top != Old_Top)

root implication check-- split pred: New_Ret != Old_Top
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root implication check-- split pred: New_Ret == Old_Top
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root implication check-- split pred: New_Ret != New_Top
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root implication check-- split pred: New_Ret == New_Top
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root for k = 2 : New_ContainsNewRet

Houdini AlwaysTrue for k=1 : (New_Top == Old_Top)

root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
root Left implication check-- split pred: New_Ret != Old_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == Old_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left implication check-- split pred: New_Ret != New_Top
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)

root Left implication check-- split pred: New_Ret == New_Top
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top && New_Ret == New_Top)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

Predicate: root Left for k = 1 : New_Ret == New_Top

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)

root Left Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top)
root Left:  for k = 2 : ((New_Top == Old_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count && New_Ret == Old_Top) && New_Ret == New_Top) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Ret != Old_Top && New_Ret != New_Top) && (!(New_Ret == New_Top)))))
root Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=1 : true

root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

root Right from implication check-- split from pred New_Ret != New_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret != New_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

root Right implication check-- split pred: New_Ret != Old_Top
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)

root Right implication check-- split pred: New_Ret == Old_Top
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count && New_Ret == Old_Top)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right implication check-- split pred: New_Ret != New_Top
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)

root Right implication check-- split pred: New_Ret == New_Top
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count && New_Ret == New_Top)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count && New_Ret != New_Top)

Predicate: root Right for k = 1 : New_Ret == Old_Top

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)

root Right Right:  for k = 1 : (Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top)
root Right:  for k = 2 : (true && (((New_s1Count == 0 && New_Ret == 0 && Old_Top == Old_s1Count && Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count && Old_Top != New_s1Count && New_Ret != Old_Top) && (!(New_Ret == Old_Top)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == Old_Top) && New_Ret == New_Top) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == 0 &&  New_Ret == 0 &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Ret != Old_Top) && (!(New_Ret == Old_Top))))) && (!(New_ContainsNewRet)))))

===== Final Result for PUT_CountContract

postcondition k == 2
((New_s1Count == Old_s1Count && New_Ret == Old_s1Count && New_Ret == New_s1Count) && ((((New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count &&  New_Top == New_s1Count &&  New_Ret == Old_Top) && New_Ret == New_Top) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count &&  New_Ret != Old_Top &&  New_Ret != New_Top) && (!(New_Ret == New_Top))))) && New_ContainsNewRet) || ((true && (((New_s1Count == 0 &&  New_Ret == 0 &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Ret == Old_Top) || ((Old_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Ret != Old_Top) && (!(New_Ret == Old_Top))))) && (!(New_ContainsNewRet)))))
rounds: 5

simplified post k == 2
((New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Top == Old_Top && New_ContainsNewRet) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && New_Ret == 0 && (!(New_ContainsNewRet))) || (New_Ret == Old_s1Count && New_Ret == New_s1Count && (!(New_Ret == Old_Top)) && (!(New_ContainsNewRet))))
pex time: 280.37822794914246

learn time: 84.67868876457214

Samples: 28

Not(k0 -> k2)? sat

Not(k1 -> k2)? sat

PUT: PUT_ContainsContract

=====
Case: k == 0

#############
Round: 1

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

unsimplified post:
(New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

#############
Round: 2

Houdini AlwaysTrue for k=0 : (New_s1Count == Old_s1Count)

unsimplified post:
(New_s1Count == Old_s1Count)

===== Final Result for PUT_ContainsContract

postcondition k == 0
(New_s1Count == Old_s1Count)
rounds: 3

simplified post k == 0
((New_s1Count == Old_s1Count))
pex time: 89.56652355194092

learn time: 3.539210081100464

Samples: 9

=====
Case: k == 1

#############
Round: 1

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root for k = 1 : New_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Ret && Old_s1ContainsX && New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left:  for k = 1 : (New_Ret && Old_s1ContainsX && New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
Houdini AlwaysTrue for k=0 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right:  for k = 1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top) && (((New_Ret && Old_s1ContainsX && New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 1 : New_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root Left:  for k = 1 : (New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right:  for k = 1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))
unsimplified post:
((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

#############
Round: 3

Houdini AlwaysTrue for k=1 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 1 : New_s1ContainsX

Houdini AlwaysTrue for k=0 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)

root Left:  for k = 1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)
Houdini AlwaysTrue for k=0 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right:  for k = 1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))
unsimplified post:
((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))

===== Final Result for PUT_ContainsContract

postcondition k == 1
((New_s1Count == Old_s1Count) && (((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && New_s1ContainsX) || (((!(New_Ret)) && (!(Old_s1ContainsX))) && (!(New_s1ContainsX)))))
rounds: 4

simplified post k == 1
((New_s1Count == Old_s1Count && New_Ret && Old_s1ContainsX && New_Top == Old_Top && New_s1ContainsX) || (New_s1Count == Old_s1Count && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX))))
pex time: 152.92412161827087

learn time: 21.773080587387085

Samples: 15

Not(k0 -> k1)? sat

Not(k1 -> k0)? sat

=====
Case: k == 2

#############
Round: 1

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_Top != Old_Top

called learn3 with 0 feature vectors
root Left Left:  for k = 1 : false
root Left Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Left Right:  for k = 1 : true
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count) && New_Top == New_s1Count) || ((New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count && New_Top == 0 && New_Top == Old_Top) && ((((New_Ret && Old_s1ContainsX && New_s1Count == 1 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && ((false && New_Top != Old_Top) || (true && (!(New_Top != Old_Top))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((New_s1Count == 1 &&  Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

#############
Round: 2

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == Old_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred Old_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred Old_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top == New_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top == New_s1Count: not expressive in with conjunctions
root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_s1Count != Old_s1Count

called learn3 with 0 feature vectors
root Left Left:  for k = 1 : false
root Left Right: not expressive in with conjunctions
Houdini AlwaysTrue for k=0 : true

root Left Right:  for k = 1 : true
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && ((false && New_s1Count != Old_s1Count) || (true && (!(New_s1Count != Old_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == 0 && New_Top == 0 && New_Top == Old_s1Count)

root Right Left:  for k = 1 : (New_s1Count == 0 && New_Top == 0 && New_Top == Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 && New_Top == 0 && New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count && New_Top == Old_Top) && ((false && New_s1Count != Old_s1Count) || (true && (!(New_s1Count != Old_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_s1Count == 0 &&  New_Top == 0 &&  New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

#############
Round: 3

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_Top == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)

root Left Left:  for k = 1 : (New_s1Count == 1 && New_Top == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left Right:  for k = 1 : (New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_s1Count == 1 && New_Top == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count) && New_Top == New_s1Count) || ((New_Top == 0 && Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_s1Count == 1 &&  New_Top == 1 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((New_Top == 0 &&  Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

#############
Round: 4

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_s1Count == 1 && New_Top == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)

root Left Left:  for k = 1 : (New_s1Count == 1 && New_Top == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_s1Count == 1 && New_Top == 1 && Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_s1Count == 1 &&  New_Top == 1 &&  Old_Top == Old_s1Count &&  New_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

#############
Round: 5

Houdini AlwaysTrue for k=2 : (New_s1Count == Old_s1Count)

root implication check-- split pred: New_Ret
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Old_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: New_s1ContainsX
root implication check-- featurePos: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))

root implication check-- split pred: Not(New_Ret)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(Old_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root implication check-- split pred: Not(New_s1ContainsX)
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)))
root implication check-- featureNeg: (New_Ret && Old_s1ContainsX && New_s1ContainsX && New_Top == Old_Top)

root from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root implication check-- split pred: Old_Top != Old_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == Old_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == Old_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: Old_Top != New_s1Count
root implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root implication check-- split pred: Old_Top == New_s1Count
root implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root implication check-- split pred: New_Top != New_s1Count
root implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root implication check-- split pred: New_Top == New_s1Count
root implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root implication check-- split pred: New_Top != Old_Top
root implication check-- featurePos: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)
root implication check-- featureNeg: (New_Top == Old_Top)

root implication check-- split pred: New_Top == Old_Top
root implication check-- featurePos: (New_Top == Old_Top)
root implication check-- featureNeg: ((!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX)) && New_Top != Old_Top)

Predicate: root for k = 2 : New_s1ContainsX

Houdini AlwaysTrue for k=1 : (New_Ret && Old_s1ContainsX && New_Top == Old_Top)

root Left from implication check-- split from pred Not(New_Ret): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(New_Ret): not expressive in with conjunctions
root Left from implication check-- split from pred Not(Old_s1ContainsX): houdini Called with 0 feature vectors
root Left from implication check-- split from pred Not(Old_s1ContainsX): not expressive in with conjunctions
root Left from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Left implication check-- split pred: Old_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != Old_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == Old_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: Old_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: Old_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left implication check-- split pred: New_Top != New_s1Count
root Left implication check-- featurePos: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left implication check-- featureNeg: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)

root Left implication check-- split pred: New_Top == New_s1Count
root Left implication check-- featurePos: (Old_Top == Old_s1Count && New_Top == Old_s1Count && Old_Top == New_s1Count && New_Top == New_s1Count)
root Left implication check-- featureNeg: (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left from implication check-- split from pred New_Top != Old_Top: houdini Called with 0 feature vectors
root Left from implication check-- split from pred New_Top != Old_Top: not expressive in with conjunctions
Predicate: root Left for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Left Left:  for k = 1 : (New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count)
Houdini AlwaysTrue for k=0 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)

root Left Right:  for k = 1 : (Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count)
root Left:  for k = 2 : ((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_Top == Old_s1Count && Old_Top == Old_s1Count && Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count && New_Top != Old_s1Count && Old_Top != New_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
Houdini AlwaysTrue for k=1 : ((!(New_Ret)) && (!(Old_s1ContainsX)))

root Right from implication check-- split from pred New_Ret: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_Ret: not expressive in with conjunctions
root Right from implication check-- split from pred Old_s1ContainsX: houdini Called with 0 feature vectors
root Right from implication check-- split from pred Old_s1ContainsX: not expressive in with conjunctions
root Right from implication check-- split from pred New_s1Count != Old_s1Count: houdini Called with 0 feature vectors
root Right from implication check-- split from pred New_s1Count != Old_s1Count: not expressive in with conjunctions
root Right implication check-- split pred: Old_Top != Old_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == Old_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == Old_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: Old_Top != New_s1Count
root Right implication check-- featurePos: (Old_Top != Old_s1Count && Old_Top != New_s1Count)
root Right implication check-- featureNeg: (Old_Top == Old_s1Count && Old_Top == New_s1Count)

root Right implication check-- split pred: Old_Top == New_s1Count
root Right implication check-- featurePos: (Old_Top == Old_s1Count && Old_Top == New_s1Count)
root Right implication check-- featureNeg: (Old_Top != Old_s1Count && Old_Top != New_s1Count)

root Right implication check-- split pred: New_Top != New_s1Count
root Right implication check-- featurePos: (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right implication check-- featureNeg: (New_Top == Old_s1Count && New_Top == New_s1Count)

root Right implication check-- split pred: New_Top == New_s1Count
root Right implication check-- featurePos: (New_Top == Old_s1Count && New_Top == New_s1Count)
root Right implication check-- featureNeg: (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right implication check-- split pred: New_Top != Old_Top
root Right implication check-- featurePos: (New_Top != Old_Top)
root Right implication check-- featureNeg: (New_Top == Old_Top)

root Right implication check-- split pred: New_Top == Old_Top
root Right implication check-- featurePos: (New_Top == Old_Top)
root Right implication check-- featureNeg: (New_Top != Old_Top)

Predicate: root Right for k = 1 : New_Top == New_s1Count

Houdini AlwaysTrue for k=0 : (New_Top == Old_s1Count)

root Right Left:  for k = 1 : (New_Top == Old_s1Count)
Houdini AlwaysTrue for k=0 : (New_Top != Old_s1Count && New_Top != New_s1Count)

root Right Right:  for k = 1 : (New_Top != Old_s1Count && New_Top != New_s1Count)
root Right:  for k = 2 : (((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count && New_Top != New_s1Count) && (!(New_Top == New_s1Count)))))
unsimplified post:
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))

===== Final Result for PUT_ContainsContract

postcondition k == 2
((New_s1Count == Old_s1Count) && ((((New_Ret && Old_s1ContainsX && New_Top == Old_Top) && (((New_Top == Old_s1Count &&  Old_Top == Old_s1Count &&  Old_Top == New_s1Count) && New_Top == New_s1Count) || ((Old_Top != Old_s1Count &&  New_Top != Old_s1Count &&  Old_Top != New_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && New_s1ContainsX) || ((((!(New_Ret)) && (!(Old_s1ContainsX))) && (((New_Top == Old_s1Count) && New_Top == New_s1Count) || ((New_Top != Old_s1Count &&  New_Top != New_s1Count) && (!(New_Top == New_s1Count))))) && (!(New_s1ContainsX)))))
rounds: 6

simplified post k == 2
((New_s1Count == Old_s1Count && New_Ret && Old_s1ContainsX && New_Top == Old_Top && New_s1ContainsX) || (New_s1Count == Old_s1Count && (!(New_Ret)) && (!(Old_s1ContainsX)) && (!(New_s1ContainsX))))
pex time: 163.95147228240967

learn time: 87.21530246734619

Samples: 34

Not(k0 -> k2)? sat

Not(k1 -> k2)? unsat

